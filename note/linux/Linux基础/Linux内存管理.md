
Linux系统中物理内存在存储上就是一个超级数组，按照字节一个个编码

但是Linux系统管理内存，是以内存页进行管理的，一般来说一个物理内存页是4k

>不使用字节进行管理是因为内存管理本身也需要消耗资源，按字节管理资源不够无法实现，因此通过内存页进行管理
>**内存页是Linux内存管理的最小单位，一个进程启动，申请资源，Linux会至少给他分配一个内存页**


**内存浪费：当Linux程序启动之后，并没有实际使用满4k大小的内存，或者4k整数倍的内存，那么这些分配给进程的内存页就存在内存浪费的情况**
Linux会通过以下手段防止内存浪费：
- 延迟分配：进程申请堆空间的时候，内核仅分配虚拟地址空间，实际物理内存页在首次访问时才分配（这里内核会给进程预留该内存页，不会让其他进程访问该内存页，只能说这种方式防止了内存浪费占用的情况，但是并没有将内存给到其他进程充分利用）
- 写时复制：fork()创建子进程的时候，父子进程共享相同的物理内存页，直到某进程尝试修改数据，同时有时为了节省内存，也会让两个进程共享内存页，如果两个进程同时触发写入的时候，就会将原有内存页内容复制到其他内存页并把新内存页分配给其中一个进程。
- 内存压缩：内核（如 `zswap` 或 `zram`）将未活跃的内存页压缩后存放，减少物理内存占用。
- 交换：将长时间未访问的内存页写入磁盘交换分区（Swap），释放物理内存。
- 透明大页：内核自动将小页合并为大页（如 2MB），减少页表项和 TLB 压力，但可能因内部碎片浪费内存。
- 需求加载：当open文件的时候，并不会马上将文件读取到内存中，只有当实际read要使用的时候，才会去把磁盘上的文件加载到内存中


虚拟内存：进程使用到的虚拟内存，**只有实际使用到的时候才会给你分配物理内存**

共享内存：两个进程之间的共享内存，即将内存页映射到两个进程里面，对于进程1可能获取到的是0x400，进程2获取到地址为0x800，但是**实际写入的时候都会映射到对应的同一块物理内存中**
>两个进程可以同时读同一块内存，如果要同时写一块内存页的时候才会为其中一个进程分配新的内存页。

