# QT学习笔记

> Qt的界面里面有示例功能，可以作为参考学习使用

## 界面解析

![image-20241017004359409](./assets/image-20241017004359409.png)

## 项目创建

- 编译系统，可以选择编译器

![image-20241018222217841](./assets/image-20241018222217841.png)

- 类信息配置

![image-20241018222703119](./assets/image-20241018222703119.png)

类信息的配置可以帮助我们直接生成一个对应的代码框架与配置头文件

可以配置的三个类信息

`QWidget QMainWindow QDiaglog`

其中，`Qwidget`为父类，会提供一个最基本的页面

它的两个子类分别会有以下作用:

- `QMainWindow`：生成一个基础界面，涵盖选项框、工具栏、状态栏等等，以我们的QT编辑器为参考，有如下图：

  ![image-20241018223657951](./assets/image-20241018223657951.png)

- `QDiaglog`：如名称所示，会生成一个基础的对话框，涵盖对话按钮等，以我们的QT界面为参考，有如下图：

  ![image-20241018223819309](./assets/image-20241018223819309.png)

图中的`Generate form`选项，可以创建一个基础的界面，可以在QT的设计界面中使用拖拽的方式来创建UI

![image-20241018224327069](./assets/image-20241018224327069.png)

![image-20241018225904002](./assets/image-20241018225904002.png)

![image-20241020203808276](./assets/image-20241020203808276.png)

### Qt基本模块

![image-20241020202803472](./assets/image-20241020202803472.png)

### Qt快捷键

![image-20241020205155151](./assets/image-20241020205155151.png)

##  API介绍

### 信号槽

信号槽的创建使用`connect`函数

`#include <QObject>`

```
QMetaObject::Connection QObject::connect	\
	(const QObject *sender, const char *signal, const QObject *receiver, const char *method,	\
    Qt::ConnectionType type = Qt::AutoConnection)
```

实际使用起来如下

```
QObject::connect(btn,&QPushButton::clicked,this,&Widget::close);
```

其中btn为控件指针，this为接收者指针

另外两个参数为信号，需要传递指针过去

### 按钮控件

`#include <QPushButton>`

![image-20241020224414519](./assets/image-20241020224414519.png)



## 对象树

对象树用于管理Qt窗口各个控件的生命周期，当我们结束程序的时候，各个控件的指针会依次从最底层开始进行析构释放

![image-20241020233130730](./assets/image-20241020233130730.png)

注意此处是对象树，而非继承树，因此哪怕不是继承自父对象的类，也可以添加进这个对象树中

只要是继承自QObject的子类即可，因此在Qt中，尽量在构造的时候指定parent对象，并且大胆在堆上创建

## 信号和槽

以创建按钮关闭窗口的需求为例

```
flowchart LR
	Button --Click-->Window-->Close
```

而这里的例子可以拟合成如下步骤

```
flowchart LR
	SignalSender--Signal-->SignalAccepter-->SignalProc
```

这里的`SignalProc`就是`信号槽`

> [!NOTE]
>
> 信号槽的优点可以综合为以下几点：
>
> - 松散耦合
> - 发送端与接收端本身没有关联，通过`connect`将两端耦合在一起





## C/C++



### 静态成员与非静态成员

静态成员可以理解为类似全局函数的东西，只不过为了管理方便我们将其划分到了类里面

它并不依赖类的实例创建，**不论你这个类创建了多少个，被多少个子类继承，静态成员永远就只有那一个**。

#### 成员

| 特性                     | 静态成员                                       | 非静态成员                                     |
| ------------------------ | ---------------------------------------------- | ---------------------------------------------- |
| 是否属于具体对象         | 否（属于类本身）                               | 是（属于具体对象）                             |
| 内存分配                 | 类级别，全局唯一                               | 对象级别，每个对象都有自己的副本               |
| 访问方式                 | 通过类名或对象访问（推荐类名访问）             | 必须通过对象访问                               |
| 生命周期                 | 随类的生命周期（类加载时创建，程序结束时销毁） | 随对象的生命周期（对象创建时存在，销毁时结束） |
| 是否共享                 | 所有对象共享同一份                             | 每个对象拥有独立的一份                         |
| 能否被静态成员函数访问   | 可以                                           | 不可以                                         |
| 能否被非静态成员函数访问 | 可以                                           | 可以                                           |



#### 成员函数

| 特性               | 静态成员函数                           | 非静态成员函数               |
| ------------------ | -------------------------------------- | ---------------------------- |
| 是否依赖对象       | 不依赖（属于类本身）                   | 依赖（属于类的具体对象）     |
| 调用方式           | 通过类名直接调用 `AClass::Function();` | 通过对象调用 `A.Function();` |
| 能否访问静态成员   | 可以                                   | 可以                         |
| 能否访问非静态成员 | 不可以                                 | 可以                         |
| 是否有 `this` 指针 | 没有                                   | 有                           |
| 内存分配           | 类级别，全局唯一                       | 对象级别，不同对象独立       |

简单来讲，静态成员函数类似我们普通定义的函数，只是为了扩展我们将其定义到了类里面，其使用方式、各方面特性都与普通函数类似

> [!NOTE]
>
> 比较特殊的是静态成员函数只能访问类中的静态成员，这也是合理的，因为我们可以在没有实例的情况下调用该函数，实例都没有，那里面的变量也没有初始化，如何访问。



















































































